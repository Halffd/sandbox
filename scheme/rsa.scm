#lang scheme
;; Helper Functions
(define (square x) (* x x))
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m)) m))
        (else
         (remainder (* base (expmod base (- exp 1) m)) m))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

;; Generate a large random number with specified bit length
(define (random-large-number bits)
  (display "Generating random number with ")
  (display bits)
  (display " bits...\n")
  (let ((result 0))
    (do ((i 0 (+ i 1)))
        ((= i bits) (+ result (expt 2 (- bits 1))))
      (set! result (+ result (* (random 2) (expt 2 i)))))
    (display "Generated: ")
    (display result)
    (newline)
    result))

;; Prime generation with feedback
(define (generate-large-prime bits)
  (display "Searching for a prime with ~")
  (display bits)
  (display " bits...\n")
  (let ((candidate (random-large-number bits)))
    (display "Testing if ")
    (display candidate)
    (display " is prime...\n")
    (if (fast-prime? candidate 20)
        (begin
          (display "Found prime: ")
          (display candidate)
          (newline)
          candidate)
        (begin
          (display "Not prime. Trying again...\n")
          (generate-large-prime bits)))))

;; GCD calculation for key generation
(define (gcd a b)
  (display "Computing GCD of ")
  (display a)
  (display " and ")
  (display b)
  (display "...\n")
  (if (= b 0)
      (begin
        (display "Result: ")
        (display a)
        (newline)
        a)
      (gcd b (remainder a b))))

;; Extended Euclidean Algorithm with detailed output
(define (extended-gcd a b)
  (display "Extended GCD for ")
  (display a)
  (display " and ")
  (display b)
  (display "...\n")
  (if (= a 0)
      (let ((result (list b 0 1)))
        (display "Base case: g=")
        (display b)
        (display ", s=0, t=1\n")
        result)
      (let* ((r (remainder b a))
             (_ (display "Recursing with "))
             (_ (display r))
             (_ (display " and "))
             (_ (display a))
             (_ (display "...\n"))
             (gcd-values (extended-gcd r a))
             (g (car gcd-values))
             (s (cadr gcd-values))
             (t (caddr gcd-values))
             (new-s (- t (* (quotient b a) s)))
             (new-t s))
        (display "Result: g=")
        (display g)
        (display ", s=")
        (display new-s)
        (display ", t=")
        (display new-t)
        (newline)
        (list g new-s new-t))))

(define (mod-inverse a m)
  (display "Computing modular inverse of ")
  (display a)
  (display " modulo ")
  (display m)
  (display "...\n")
  (let* ((result (cadr (extended-gcd a m)))
         (final-result (if (< result 0) (+ result m) result)))
    (display "Modular inverse: ")
    (display final-result)
    (newline)
    final-result))

;; Generate RSA key pair with detailed output
(define (generate-key-pair bits)
  (display "\n==== GENERATING RSA KEY PAIR ====\n")
  (display "Bit strength: ")
  (display bits)
  (newline)
  
  (display "\nGenerating first prime (p)...\n")
  (let* ((p (generate-large-prime (quotient bits 2)))
         (_ (display "\nGenerating second prime (q)...\n"))
         (q (generate-large-prime (quotient bits 2)))
         (_ (display "\nComputing n = p * q...\n"))
         (n (* p q))
         (_ (display "n = "))
         (_ (display n))
         (_ (newline))
         (_ (display "\nComputing φ(n) = (p-1) * (q-1)...\n"))
         (phi (* (- p 1) (- q 1)))
         (_ (display "φ(n) = "))
         (_ (display phi))
         (_ (newline))
         (e 65537)
         (_ (display "\nUsing public exponent e = 65537\n"))
         (_ (display "\nComputing private exponent d...\n"))
         (d (mod-inverse e phi)))
    
    (display "\n==== KEY PAIR GENERATED ====\n")
    (display "Public key (e, n): (")
    (display e)
    (display ", ")
    (display n)
    (display ")\n")
    (display "Private key (d, n): (")
    (display d)
    (display ", ")
    (display n)
    (display ")\n\n")
    (list (cons e n) (cons d n))))

;; Encrypt a message with output
(define (encrypt m public-key)
  (display "==== ENCRYPTION ====\n")
  (display "Message: ")
  (display m)
  (newline)
  (let ((e (car public-key))
        (n (cdr public-key)))
    (display "Public key (e, n): (")
    (display e)
    (display ", ")
    (display n)
    (display ")\n")
    (display "Computing c = m^e mod n...\n")
    (let ((result (expmod m e n)))
      (display "Ciphertext: ")
      (display result)
      (newline)
      result)))

;; Decrypt a ciphertext with output
(define (decrypt c private-key)
  (display "\n==== DECRYPTION ====\n")
  (display "Ciphertext: ")
  (display c)
  (newline)
  (let ((d (car private-key))
        (n (cdr private-key)))
    (display "Private key (d, n): (")
    (display d)
    (display ", ")
    (display n)
    (display ")\n")
    (display "Computing m = c^d mod n...\n")
    (let ((result (expmod c d n)))
      (display "Decrypted message: ")
      (display result)
      (newline)
      result)))

;; Test RSA with detailed output
(define (test-rsa)
  (display "======= RSA DEMONSTRATION =======\n\n")
  (let* ((keys (generate-key-pair 32))  ; Using small bit size for demonstration
         (public-key (car keys))
         (private-key (cadr keys))
         (message 42))
    
    (display "\n==== TEST MESSAGE ====\n")
    (display "Original message: ")
    (display message)
    (newline)
    
    (let ((encrypted (encrypt message public-key)))
      (let ((decrypted (decrypt encrypted private-key)))
        (display "\n==== VERIFICATION ====\n")
        (display "Original: ")
        (display message)
        (display "\nDecrypted: ")
        (display decrypted)
        (display "\nSuccessful? ")
        (display (= message decrypted))
        (newline)))))

;; Run the demonstration
(test-rsa)
