#lang scheme
(define nil '())
(define (square x) (* x x))
(define a (cons 1
      (cons 2
            (cons 3
                  (cons 4 0)))))
(define one-through-four (list 1 2 3 4))
(car one-through-four)
(cdr one-through-four)
(car (cdr one-through-four))
(cons 10 one-through-four)
(cons 5 one-through-four)
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))

(list-ref squares 1)
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5 7))

(length odds)
(define (length-it items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
(append squares odds)
(append odds squares)
(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items) factor))))
(scale-list (list 1 2 3 4 5) 10)

(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
(define (map2 proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map2 proc (cdr items)))))
(map2 abs (list -10 2.5 -11.6 17))
(map2 (lambda (x) (* x x))
     (list 1 2 3 4))
(define (scale items factor)
  (map (lambda (x) (* x factor))
       items))
(map (lambda (x) (* 2 (sin x))) (list 3 7 9 3 5 44))
(scale (list 3 7 9 3 5 44) (* 2 (sin 1)))
(cons (list 1 2) (list 3 4))
(define x (cons (list 1 2) (list 3 4)))

(length x)
(define (count-leaves x)
  (cond ((null? x) 0)  
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))

(count-leaves x)
(list x x)
(length (list x x))
(length (list x (list x x)))
(count-leaves (list x x))
(pair? (cons 1 2))     ; #t - yep, it's a pair
(pair? 42)             ; #f - just a number
(pair? "hello")        ; #f - just a string  
(pair? '())            ; #f - empty list isn't a pair
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))

(define (scale-tr tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tr sub-tree factor)
             (* sub-tree factor)))
       tree))
(scale-tr (list 1 (list 2 (list 3 4) 5) (list 6 7))
            10)
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)  
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
(define (fib n)
  (display (string-append "Computing fibonacci(" (number->string n) ")\n"))
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
(define (even-fibs n)
  (define (next k)
    (if (> k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
(sum-odd-squares (list 3 2 1 1 1 2))
(even-fibs 4)
(map square (list 41 42 43 44 55))
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
(filter odd? (list 1 2 3 4 5))
