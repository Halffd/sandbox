(defun ackermann (n m &optional (depth 0))
  (let* ((indent   (make-string (* depth 2) :initial-element #\ ))
         (call-str (format nil "~aAckermann(~d, ~d)" indent n m)))
    (format t "~a [Call]~%" call-str)
    ;; start-time binding is its own let
    (let ((start-time (get-internal-real-time)))
      ;; prog1 wraps the recursive logic so we can compute elapsed afterwards
      (prog1
          (cond
            ((= n 0)
             (let ((result (1+ m)))
               (format t "~a [Return ~d] (Base case n=0)~%" call-str result)
               result))
            ((and (> n 0) (= m 0))
             (let ((result (ackermann (1- n) m (1+ depth))))
               (format t "~a [Return ~d] (Case n>0 and m=0)~%" call-str result)
               result))
            (t
             (let* ((inner  (ackermann n (1- m) (1+ depth)))
                    (result (ackermann (1- n) inner (1+ depth))))
               (format t "~a [Return ~d] (Recursive case)~%" call-str result)
               result)))
        ;; this code runs after the cond returns
        (let ((elapsed (/ (- (get-internal-real-time) start-time)
                         internal-time-units-per-second)))
          (format t "~a [Time ~,3f seconds]~%" call-str elapsed))))))

(define (timed-ackermann n m)
  (display "\nComputing Ackermann(")
  (display n)
  (display ", ")
  (display m)
  (display ")\n")
  (let ((start-time (current-seconds))
        (result (ackermann n m)))
    (let ((elapsed (- (current-seconds) start-time)))
      (display "\nFinal result: ")
      (display result)
      (display "\nTotal execution time: ")
      (display elapsed)
      (display " seconds\n")
      result))
(defun ackermann (n m)
  (cond ((= n 0) (1+ m))
        ((and (> n 0) (= m 0)) (ackermann (1- n) m))
        (t (ackermann (1- n) (ackermann n (1- m))))))
(ackermann 1 1)
